/**
 * @fileoverview Firestore Security Rules for EduSpark application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and quiz results,
 * and allows public read access with owner-only writes for community posts.
 * Data consistency is enforced between document IDs and internal user ID fields.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information, accessible only to the owner.
 * - /users/{userId}/quizResults/{quizResultId}: Stores quiz results for each user, accessible only to the owner.
 * - /quizzes/{quizId}: Stores quiz definitions (publicly readable).
 * - /questions/{questionId}: Stores question details (publicly readable).
 * - /badges/{badgeId}: Stores badge information (publicly readable).
 * - /studySessions/{studySessionId}: Stores study session details, accessible only to the session owner and participants.
 * - /posts/{postId}: Stores community posts (publicly readable, owner-only writes).
 * - /posts/{postId}/comments/{commentId}: Stores comments on posts (owner-only writes).
 * - /friendRequests/{requestId}: Stores friend requests between users (accessed only by the involved users).
 *
 * Key Security Decisions:
 * - Users can only access their own profile data and quiz results.
 * - Posts are publicly readable, but only the owner can create, update, or delete them.
 * - Study sessions are accessible to the owner and participants.
 * - Data validation is limited to enforcing ownership and relational integrity (e.g., userId in quizResult matches the path).
 *
 * Denormalization for Authorization:
 *  - The rules rely on the `userId` present in the path `/users/{userId}` matching the `id` field within the document.
 *  - Posts have a `userId` field to determine ownership for write operations.
 *
 * Structural Segregation:
 *  - Quiz results are stored in user-specific subcollections to ensure only the owner can access them.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Defines a global function to check if a user is signed in.
     * @returns {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Defines a global function to check if the request is made by the owner.
     * @param {string} userId The user ID to compare with the request's authentication UID.
     * @returns {boolean} True if the user ID matches the request's authentication UID.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Defines a global function to check if the request is made by the existing owner.
     * @param {string} userId The user ID to compare with the resource data and the request's authentication UID.
     * @returns {boolean} True if the user ID matches the resource data and the request's authentication UID.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Defines a global function to check if the request is made by participant.
     * @param {array} participants The array containing user IDs of participants.
     * @returns {boolean} True if the user is signed in and is a participant.
     */
    function isParticipant(participants) {
        return isSignedIn() && request.auth.uid in participants;
    }

    /***************** USERS ******************/

    /**
     * @description Grants access to user profiles, allowing only the owner to read and write.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile with matching userId.
     * @deny (create) User with ID 'user123' cannot create a profile with a different userId.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /***************** QUIZ RESULTS ******************/

    /**
     * @description Grants access to quiz results, allowing only the owner to read and write.
     * @path /users/{userId}/quizResults/{quizResultId}
     * @allow (create) User with ID 'user123' can create their quiz result with matching userId.
     * @deny (create) User with ID 'user123' cannot create a quiz result with a different userId.
     * @principle Enforces document ownership for quiz results.
     */
    match /users/{userId}/quizResults/{quizResultId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /***************** QUIZZES ******************/

    /**
     * @description Allows public read access to quizzes.
     * @path /quizzes/{quizId}
     * @allow (get) Any user can read quiz data.
     * @deny (create) No user can create, update, or delete quiz data.
     * @principle Allows public read access to quiz definitions.
     */
    match /quizzes/{quizId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /***************** QUESTIONS ******************/

    /**
     * @description Allows public read access to questions.
     * @path /questions/{questionId}
     * @allow (get) Any user can read question data.
     * @deny (create) No user can create, update, or delete question data.
     * @principle Allows public read access to question details.
     */
    match /questions/{questionId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /***************** BADGES ******************/

    /**
     * @description Allows public read access to badges.
     * @path /badges/{badgeId}
     * @allow (get) Any user can read badge data.
     * @deny (create) No user can create, update, or delete badge data.
     * @principle Allows public read access to badge information.
     */
    match /badges/{badgeId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /***************** STUDY SESSIONS ******************/

    /**
     * @description Grants access to study sessions, allowing the owner and participants to read and write.
     * @path /studySessions/{studySessionId}
     * @allow (get) Owner or participant can read study session data.
     * @deny (create) User cannot create a study session without being the owner or participant.
     * @principle Enforces document ownership and shared access for study sessions.
     */
    match /studySessions/{studySessionId} {
      allow get: if isSignedIn() && (resource.data.ownerId == request.auth.uid || request.auth.uid in resource.data.participants);
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId) || (isSignedIn() && request.auth.uid in resource.data.participants);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /***************** POSTS ******************/

    /**
     * @description Allows public read access to posts, but restricts write access to the owner only.
     * @path /posts/{postId}
     * @allow (get) Any user can read post data.
     * @allow (create) Owner can create a post with matching userId.
     * @deny (update) User cannot update a post they don't own.
     * @principle Allows public read access to posts while enforcing document ownership for writes.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /***************** COMMENTS ******************/

    /**
     * @description Grants access to comments on posts, allowing only authenticated users to create comments and the owner to update and delete.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (create) Authenticated user can create a comment.
     * @deny (update) User cannot update a comment they don't own.
     * @principle Enforces authentication for comment creation and document ownership for updates and deletes.
     */
    match /posts/{postId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /***************** LIKES ******************/
        /**
         * @description Allows any authenticated user to create a like, and only the user who created the like can delete it.
         * @path /posts/{postId}/likes/{likeId}
         * @allow (create) Any authenticated user can create a like.
         * @deny (delete) User cannot delete a like they didn't create.
         * @principle Authenticated users can create likes, and ownership is required for deletion.
         */
    match /posts/{postId}/likes/{likeId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if resource.data.userId == request.auth.uid;
    }

    /***************** FRIEND REQUESTS ******************/

    /**
     * @description Controls access to friend requests, ensuring only involved users can read and write.
     * @path /friendRequests/{requestId}
     * @allow (get) User can read if they are the sender or receiver.
     * @deny (create) User cannot create a request where they are not the sender.
     * @principle Enforces that only involved users can access friend requests.
     */
    match /friendRequests/{requestId} {
        allow get: if isSignedIn() && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
        allow list: if false;
        allow create: if isSignedIn() && request.resource.data.fromUserId == request.auth.uid;
        allow update: if isSignedIn() && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
        allow delete: if false;
    }
  }
}